<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="# ERP SENA - Sistema de Gestión Empresarial&#10;&#10;## Descripción&#10;Sistema ERP (Enterprise Resource Planning) desarrollado para gestionar procesos empresariales, incluyendo gestión de usuarios, inventario, pedidos, productos y más.&#10;&#10;## Estructura del Proyecto&#10;El proyecto está dividido en dos componentes principales:&#10;&#10;### Frontend (`frontend-erp/`)&#10;- Desarrollado con React.js&#10;- Estructura de componentes reutilizables&#10;- Gestión de estado con Redux/Context API&#10;- Estilos modularizados con CSS&#10;&#10;### Backend (`backend/`)&#10;- Desarrollado con Spring Boot (Java)&#10;- Arquitectura REST&#10;- Seguridad con Spring Security&#10;- Base de datos MySQL&#10;&#10;## Requisitos Previos&#10;- Node.js (v14 o superior)&#10;- Java JDK 11 o superior&#10;- MySQL 8.0 o superior&#10;- Maven&#10;&#10;## Instalación y Configuración&#10;&#10;### Backend&#10;1. Navegar al directorio backend:&#10;```bash&#10;cd backend&#10;```&#10;&#10;2. Instalar dependencias con Maven:&#10;```bash&#10;mvn clean install&#10;```&#10;&#10;3. Configurar la base de datos:&#10;- Crear una base de datos MySQL&#10;- Configurar las credenciales en `application.properties`&#10;&#10;4. Ejecutar el servidor:&#10;```bash&#10;mvn spring-boot:run&#10;```&#10;&#10;### Frontend&#10;1. Navegar al directorio frontend:&#10;```bash&#10;cd frontend-erp&#10;```&#10;&#10;2. Instalar dependencias:&#10;```bash&#10;npm install&#10;```&#10;&#10;3. Iniciar la aplicación:&#10;```bash&#10;npm start&#10;```&#10;&#10;## Arquitectura y Capas&#10;&#10;### Capa de Presentación (Frontend)&#10;- **Componentes**: React.js&#10;- **Estilos**: CSS Modules&#10;- **Estado**: Redux/Context API&#10;- **Routing**: React Router&#10;- **Comunicación**: Axios para peticiones HTTP&#10;&#10;### Capa de Negocio (Backend)&#10;- **Framework**: Spring Boot&#10;- **Seguridad**: Spring Security, JWT&#10;- **API**: REST Controllers&#10;- **Servicios**: Business Logic&#10;- **DTO**: Data Transfer Objects&#10;&#10;### Capa de Datos&#10;- **ORM**: JPA/Hibernate&#10;- **Base de datos**: MySQL&#10;- **Repositorios**: Spring Data JPA&#10;&#10;## Seguridad&#10;- Autenticación basada en JWT&#10;- Roles y permisos de usuario&#10;- Encriptación de contraseñas&#10;- Validación de tokens&#10;- Protección contra CSRF&#10;- Headers de seguridad HTTP&#10;&#10;## Mapa de Navegación&#10;- **Login** `/login`&#10;- **Dashboard** `/dashboard`&#10;- **Usuarios** `/usuarios`&#10;- **Productos** `/productos`&#10;- **Inventario** `/inventario`&#10;- **Pedidos** `/pedidos`&#10;- **Reportes** `/reportes`&#10;- **Configuración** `/configuracion`&#10;&#10;## Metodología de Desarrollo&#10;- Metodología Ágil (Scrum)&#10;- Control de versiones con Git&#10;- Pruebas automatizadas con Postman&#10;- Desarrollo basado en componentes&#10;- Integración continua&#10;&#10;## Librerías Principales&#10;&#10;### Frontend&#10;- React.js&#10;- React Router&#10;- Axios&#10;- Material-UI/Bootstrap&#10;- Redux/Context API&#10;- React Icons&#10;- Moment.js&#10;&#10;### Backend&#10;- Spring Boot&#10;- Spring Security&#10;- Spring Data JPA&#10;- Lombok&#10;- JWT&#10;- Jackson&#10;- MySQL Connector&#10;&#10;## Control de Versiones&#10;El proyecto utiliza Git como sistema de control de versiones. Se recomienda seguir las siguientes convenciones para commits:&#10;&#10;- feat: Nuevas características&#10;- fix: Corrección de errores&#10;- docs: Documentación&#10;- style: Cambios de estilo&#10;- refactor: Refactorización de código&#10;- test: Añadir o modificar pruebas&#10;&#10;## Pruebas&#10;- Pruebas unitarias con JUnit&#10;- Pruebas de integración&#10;- Colecciones de Postman para pruebas de API&#10;- Pruebas end-to-end&#10;&#10;## Componentes Reutilizables&#10;- Formularios genéricos&#10;- Tablas de datos&#10;- Componentes de navegación&#10;- Modales&#10;- Componentes de carga&#10;- Notificaciones&#10;- Validadores&#10;&#10;## Soporte y Contacto&#10;Para soporte técnico o consultas, contactar al equipo de desarrollo a través del sistema de issues de Git.&#10;&#10;## Licencia&#10;Proyecto desarrollado para SENA. Todos los derechos reservados.&#10;" />
              <option name="updatedContent" value="#  ERP SENA - Sistema de Gestión Empresarial&#10;[![Made with React](https://img.shields.io/badge/Made_with-React-61DAFB?style=flat-square&amp;logo=react&amp;logoColor=white)](https://reactjs.org/)&#10;[![Backend Spring Boot](https://img.shields.io/badge/Backend-Spring_Boot-6DB33F?style=flat-square&amp;logo=spring&amp;logoColor=white)](https://spring.io/projects/spring-boot)&#10;[![MySQL](https://img.shields.io/badge/Database-MySQL-4479A1?style=flat-square&amp;logo=mysql&amp;logoColor=white)](https://www.mysql.com/)&#10;&#10;##  Descripción&#10;Sistema ERP (Enterprise Resource Planning) desarrollado para gestionar procesos empresariales de manera eficiente y escalable. Incluye gestión de usuarios, inventario, pedidos, productos y más.&#10;&#10;## ️ Estructura del Proyecto&#10;El proyecto está organizado en dos componentes principales:&#10;&#10;###  Frontend (`frontend-erp/`)&#10;-  Desarrollado con React.js&#10;-  Estructura de componentes reutilizables&#10;-  Gestión de estado con Redux/Context API&#10;-  Estilos modularizados con CSS&#10;&#10;### ⚙️ Backend (`backend/`)&#10;-  Desarrollado con Spring Boot (Java)&#10;-  Arquitectura REST&#10;-  Seguridad con Spring Security&#10;- ️ Base de datos MySQL&#10;&#10;##  Requisitos Previos&#10;-  Node.js (v14 o superior)&#10;- ☕ Java JDK 11 o superior&#10;- ️ MySQL 8.0 o superior&#10;- ️ Maven&#10;&#10;##  Instalación y Configuración&#10;&#10;### ⚙️ Backend&#10;1. Navegar al directorio backend:&#10;```bash&#10;cd backend&#10;```&#10;&#10;2. Instalar dependencias con Maven:&#10;```bash&#10;mvn clean install&#10;```&#10;&#10;3. Configurar la base de datos:&#10;-  Crear una base de datos MySQL&#10;- ⚙️ Configurar las credenciales en `application.properties`&#10;&#10;4. Ejecutar el servidor:&#10;```bash&#10;mvn spring-boot:run&#10;```&#10;&#10;###  Frontend&#10;1. Navegar al directorio frontend:&#10;```bash&#10;cd frontend-erp&#10;```&#10;&#10;2. Instalar dependencias:&#10;```bash&#10;npm install&#10;```&#10;&#10;3. Iniciar la aplicación:&#10;```bash&#10;npm start&#10;```&#10;&#10;## ️ Arquitectura y Capas&#10;&#10;### ️ Capa de Presentación (Frontend)&#10;-  **Componentes**: React.js&#10;-  **Estilos**: CSS Modules&#10;-  **Estado**: Redux/Context API&#10;-  **Routing**: React Router&#10;-  **Comunicación**: Axios&#10;&#10;### ⚙️ Capa de Negocio (Backend)&#10;-  **Framework**: Spring Boot&#10;-  **Seguridad**: Spring Security, JWT&#10;-  **API**: REST Controllers&#10;-  **Servicios**: Business Logic&#10;-  **DTO**: Data Transfer Objects&#10;&#10;### ️ Capa de Datos&#10;-  **ORM**: JPA/Hibernate&#10;-  **Base de datos**: MySQL&#10;-  **Repositorios**: Spring Data JPA&#10;&#10;##  Seguridad&#10;-  Autenticación basada en JWT&#10;-  Roles y permisos de usuario&#10;-  Encriptación de contraseñas&#10;-  Validación de tokens&#10;- ️ Protección contra CSRF&#10;-  Headers de seguridad HTTP&#10;&#10;## ️ Mapa de Navegación&#10;-  **Login** `/login`&#10;-  **Dashboard** `/dashboard`&#10;-  **Usuarios** `/usuarios`&#10;-  **Productos** `/productos`&#10;-  **Inventario** `/inventario`&#10;-  **Pedidos** `/pedidos`&#10;-  **Reportes** `/reportes`&#10;- ⚙️ **Configuración** `/configuracion`&#10;&#10;##  Metodología de Desarrollo&#10;-  Metodología Ágil (Scrum)&#10;-  Control de versiones con Git&#10;-  Pruebas automatizadas con Postman&#10;-  Desarrollo basado en componentes&#10;-  Integración continua&#10;&#10;##  Librerías Principales&#10;&#10;###  Frontend&#10;```json&#10;{&#10;  &quot;dependencies&quot;: {&#10;    &quot;react&quot;: &quot;^18.x&quot;,&#10;    &quot;react-router&quot;: &quot;^6.x&quot;,&#10;    &quot;axios&quot;: &quot;^1.x&quot;,&#10;    &quot;material-ui&quot;: &quot;^5.x&quot;,&#10;    &quot;redux&quot;: &quot;^4.x&quot;&#10;  }&#10;}&#10;```&#10;&#10;### ⚙️ Backend&#10;```xml&#10;&lt;dependencies&gt;&#10;    &lt;dependency&gt;&#10;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#10;    &lt;/dependency&gt;&#10;    &lt;dependency&gt;&#10;        &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;&#10;    &lt;/dependency&gt;&#10;    &lt;!-- Más dependencias... --&gt;&#10;&lt;/dependencies&gt;&#10;```&#10;&#10;##  Control de Versiones&#10;El proyecto utiliza Git con las siguientes convenciones para commits:&#10;&#10;- ✨ `feat`: Nuevas características&#10;-  `fix`: Corrección de errores&#10;-  `docs`: Documentación&#10;-  `style`: Cambios de estilo&#10;- ♻️ `refactor`: Refactorización&#10;-  `test`: Pruebas&#10;&#10;##  Pruebas&#10;- ✅ Pruebas unitarias con JUnit&#10;-  Pruebas de integración&#10;-  Colecciones de Postman&#10;-  Pruebas end-to-end&#10;&#10;##  Componentes Reutilizables&#10;-  Formularios genéricos&#10;-  Tablas de datos&#10;-  Componentes de navegación&#10;-  Modales&#10;- ⌛ Componentes de carga&#10;-  Notificaciones&#10;- ✅ Validadores&#10;&#10;##  Soporte y Contacto&#10;Para soporte técnico o consultas, contactar al equipo de desarrollo a través del sistema de issues de Git.&#10;&#10;##  Licencia&#10;Proyecto desarrollado para SENA. Todos los derechos reservados.&#10;&#10;---&#10;&lt;div align=&quot;center&quot;&gt;&#10;    &lt;p&gt;Desarrollado con ❤️ por el equipo ERP SENA&lt;/p&gt;&#10;    &lt;img src=&quot;https://img.shields.io/badge/Estado-En_Desarrollo-blue?style=for-the-badge&amp;logo=dev.to&amp;logoColor=white&quot; alt=&quot;Estado del Proyecto&quot;/&gt;&#10;&lt;/div&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/main/java/com/empresa/erp/config/SecurityConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/main/java/com/empresa/erp/config/SecurityConfig.java" />
              <option name="originalContent" value="package com.empresa.erp.config;&#10;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.security.config.annotation.web.builders.HttpSecurity;&#10;import org.springframework.security.web.SecurityFilterChain;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;&#10;import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;&#10;import org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl;&#10;import org.springframework.security.access.hierarchicalroles.RoleHierarchy;&#10;import org.springframework.http.HttpMethod;&#10;import com.empresa.erp.config.RateLimitFilter;&#10;import org.springframework.web.cors.CorsConfiguration;&#10;import org.springframework.web.cors.CorsConfigurationSource;&#10;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;&#10;import java.util.Arrays;&#10;import org.springframework.security.web.authentication.AuthenticationSuccessHandler;&#10;import org.springframework.security.oauth2.core.user.OAuth2User;&#10;import org.springframework.security.oauth2.client.authentication.OAuth2AuthenticationToken;&#10;import org.springframework.security.core.Authentication;&#10;import jakarta.servlet.http.HttpServletRequest;&#10;import jakarta.servlet.http.HttpServletResponse;&#10;import jakarta.servlet.ServletException;&#10;import java.io.IOException;&#10;import com.empresa.erp.services.AuthService;&#10;import com.empresa.erp.services.UsuarioService;&#10;import com.empresa.erp.models.Usuario;&#10;import java.util.Map;&#10;import jakarta.servlet.Filter;&#10;import jakarta.servlet.FilterChain;&#10;import jakarta.servlet.http.HttpSession;&#10;import org.springframework.core.annotation.Order;&#10;import org.springframework.web.filter.OncePerRequestFilter;&#10;import org.springframework.security.web.AuthenticationEntryPoint;&#10;import org.springframework.security.web.access.AccessDeniedHandler;&#10;import org.springframework.security.web.access.AccessDeniedHandlerImpl;&#10;import org.springframework.security.web.authentication.HttpStatusEntryPoint;&#10;import org.springframework.http.HttpStatus;&#10;import jakarta.servlet.http.Cookie;&#10;&#10;@Configuration&#10;@EnableMethodSecurity&#10;public class SecurityConfig {&#10;&#10;    @Autowired&#10;    private JwtAuthenticationFilter jwtAuthenticationFilter;&#10;&#10;    @Autowired&#10;    private RateLimitFilter rateLimitFilter;&#10;&#10;    @Autowired&#10;    private AuthService authService;&#10;&#10;    @Autowired&#10;    private UsuarioService usuarioService;&#10;&#10;    @Bean&#10;    public RoleHierarchy roleHierarchy() {&#10;        RoleHierarchyImpl roleHierarchy = new RoleHierarchyImpl();&#10;        // ADMIN &gt; SUPERVISOR &gt; USER&#10;        roleHierarchy.setHierarchy(&quot;ROLE_ADMIN &gt; ROLE_SUPERVISOR \n ROLE_SUPERVISOR &gt; ROLE_USER&quot;);&#10;        return roleHierarchy;&#10;    }&#10;&#10;    @Bean&#10;    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {&#10;        http&#10;            .csrf(csrf -&gt; csrf.disable())&#10;            .cors(cors -&gt; cors.configurationSource(corsConfigurationSource()))&#10;            .authorizeHttpRequests(auth -&gt; auth&#10;                .requestMatchers(&quot;/&quot;).permitAll()&#10;                .requestMatchers(&quot;/api&quot;).permitAll()&#10;                .requestMatchers(&quot;/api/auth/**&quot;).permitAll()&#10;                .requestMatchers(&quot;/oauth2/**&quot;).permitAll()&#10;                .requestMatchers(&quot;/login/oauth2/code/**&quot;).permitAll()&#10;                .requestMatchers(&quot;/oauth/**&quot;).permitAll()&#10;                .requestMatchers(&quot;/api/test/**&quot;).permitAll()&#10;                .requestMatchers(&quot;/api/files/**&quot;).permitAll() // &lt;-- permite imágenes públicas&#10;                .requestMatchers(&quot;/api/compras/test&quot;).permitAll() // &lt;-- endpoint de prueba público&#10;                .requestMatchers(&quot;/api/compras/test-simple&quot;).permitAll() // &lt;-- endpoint de prueba simple&#10;                .requestMatchers(&quot;/api/compras/diagnostico&quot;).permitAll() // &lt;-- endpoint de diagnóstico público&#10;                .requestMatchers(&quot;/api/compras/demo&quot;).permitAll() // &lt;-- endpoint demo completamente público&#10;                .requestMatchers(&quot;/api/compras/public&quot;).authenticated() // &lt;-- endpoint público temporal&#10;                .requestMatchers(&quot;/api/usuarios/**&quot;).hasRole(&quot;ADMIN&quot;)&#10;                .requestMatchers(&quot;/api/reportes/**&quot;).hasAnyRole(&quot;ADMIN&quot;, &quot;SUPERVISOR&quot;)&#10;                .requestMatchers(HttpMethod.GET, &quot;/api/productos/**&quot;).hasAnyRole(&quot;ADMIN&quot;, &quot;SUPERVISOR&quot;, &quot;USER&quot;)&#10;                .requestMatchers(HttpMethod.POST, &quot;/api/productos/**&quot;).hasRole(&quot;ADMIN&quot;)&#10;                .requestMatchers(HttpMethod.PUT, &quot;/api/productos/**&quot;).hasRole(&quot;ADMIN&quot;)&#10;                .requestMatchers(HttpMethod.DELETE, &quot;/api/productos/**&quot;).hasRole(&quot;ADMIN&quot;)&#10;                .requestMatchers(HttpMethod.GET, &quot;/api/clientes/**&quot;).hasAnyRole(&quot;ADMIN&quot;, &quot;SUPERVISOR&quot;, &quot;USER&quot;)&#10;                .requestMatchers(HttpMethod.POST, &quot;/api/clientes/**&quot;).hasAnyRole(&quot;ADMIN&quot;, &quot;SUPERVISOR&quot;)&#10;                .requestMatchers(HttpMethod.PUT, &quot;/api/clientes/**&quot;).hasAnyRole(&quot;ADMIN&quot;, &quot;SUPERVISOR&quot;)&#10;                .requestMatchers(HttpMethod.DELETE, &quot;/api/clientes/**&quot;).hasAnyRole(&quot;ADMIN&quot;, &quot;SUPERVISOR&quot;)&#10;                .requestMatchers(HttpMethod.GET, &quot;/api/pedidos/**&quot;).hasAnyRole(&quot;ADMIN&quot;, &quot;SUPERVISOR&quot;, &quot;USER&quot;)&#10;                .requestMatchers(HttpMethod.POST, &quot;/api/pedidos/**&quot;).hasAnyRole(&quot;ADMIN&quot;, &quot;SUPERVISOR&quot;)&#10;                .requestMatchers(HttpMethod.PUT, &quot;/api/pedidos/**&quot;).hasAnyRole(&quot;ADMIN&quot;, &quot;SUPERVISOR&quot;)&#10;                .requestMatchers(HttpMethod.DELETE, &quot;/api/pedidos/**&quot;).hasAnyRole(&quot;ADMIN&quot;, &quot;SUPERVISOR&quot;)&#10;                .requestMatchers(HttpMethod.GET, &quot;/api/proveedores/**&quot;).hasAnyRole(&quot;ADMIN&quot;, &quot;SUPERVISOR&quot;)&#10;                .requestMatchers(HttpMethod.POST, &quot;/api/proveedores/**&quot;).hasRole(&quot;ADMIN&quot;)&#10;                .requestMatchers(HttpMethod.PUT, &quot;/api/proveedores/**&quot;).hasRole(&quot;ADMIN&quot;)&#10;                .requestMatchers(HttpMethod.DELETE, &quot;/api/proveedores/**&quot;).hasRole(&quot;ADMIN&quot;)&#10;                .requestMatchers(HttpMethod.GET, &quot;/api/compras/**&quot;).hasAnyRole(&quot;ADMIN&quot;, &quot;SUPERVISOR&quot;)&#10;                .requestMatchers(HttpMethod.POST, &quot;/api/compras/**&quot;).hasRole(&quot;ADMIN&quot;)&#10;                .requestMatchers(HttpMethod.PUT, &quot;/api/compras/**&quot;).hasRole(&quot;ADMIN&quot;)&#10;                .requestMatchers(HttpMethod.DELETE, &quot;/api/compras/**&quot;).hasRole(&quot;ADMIN&quot;)&#10;                .requestMatchers(HttpMethod.GET, &quot;/api/movimientos-inventario/**&quot;).hasAnyRole(&quot;ADMIN&quot;, &quot;SUPERVISOR&quot;)&#10;                .requestMatchers(HttpMethod.POST, &quot;/api/movimientos-inventario/**&quot;).hasRole(&quot;ADMIN&quot;)&#10;                .requestMatchers(HttpMethod.PUT, &quot;/api/movimientos-inventario/**&quot;).hasRole(&quot;ADMIN&quot;)&#10;                .requestMatchers(HttpMethod.DELETE, &quot;/api/movimientos-inventario/**&quot;).hasRole(&quot;ADMIN&quot;)&#10;                .requestMatchers(&quot;/api/auth/login&quot;, &quot;/api/auth/refresh&quot;, &quot;/api/auth/verify-recaptcha&quot;).permitAll()&#10;                .requestMatchers(&quot;/api/auth/me&quot;).authenticated()&#10;                .anyRequest().authenticated()&#10;            )&#10;            .logout(logout -&gt; logout&#10;                .logoutUrl(&quot;/logout&quot;)&#10;                .logoutSuccessHandler((request, response, authentication) -&gt; {&#10;                    // Invalida la sesión&#10;                    if (request.getSession(false) != null) {&#10;                        request.getSession(false).invalidate();&#10;                    }&#10;                    // Borra la cookie JSESSIONID&#10;                    jakarta.servlet.http.Cookie cookie = new jakarta.servlet.http.Cookie(&quot;JSESSIONID&quot;, null);&#10;                    cookie.setPath(&quot;/&quot;);&#10;                    cookie.setHttpOnly(true);&#10;                    cookie.setMaxAge(0);&#10;                    response.addCookie(cookie);&#10;&#10;                    response.setStatus(HttpStatus.OK.value());&#10;                    response.setContentType(&quot;application/json&quot;);&#10;                    response.getWriter().write(&quot;{\&quot;message\&quot;: \&quot;Logout exitoso\&quot;}&quot;);&#10;                })&#10;            )&#10;            .oauth2Login(oauth2 -&gt; oauth2&#10;                .successHandler(oAuth2SuccessHandler())&#10;                .failureUrl(&quot;http://localhost:3001/login?error=oauth_failed&quot;)&#10;            )&#10;            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)&#10;            .addFilterBefore(rateLimitFilter, JwtAuthenticationFilter.class)&#10;            .exceptionHandling(exception -&gt; exception&#10;                .authenticationEntryPoint(new HttpStatusEntryPoint(HttpStatus.UNAUTHORIZED))&#10;                .accessDeniedHandler((request, response, accessDeniedException) -&gt; {&#10;                    response.setStatus(HttpStatus.FORBIDDEN.value());&#10;                    response.setContentType(&quot;application/json&quot;);&#10;                    response.getWriter().write(&quot;{\&quot;error\&quot;: \&quot;Forbidden\&quot;}&quot;);&#10;                })&#10;            );&#10;        return http.build();&#10;    }&#10;&#10;    @Bean&#10;    public SecurityFilterChain oauth2FilterChain(HttpSecurity http) throws Exception {&#10;        http&#10;            .securityMatcher(&quot;/oauth2/**&quot;, &quot;/login/oauth2/**&quot;)&#10;            .csrf(csrf -&gt; csrf.disable())&#10;            .cors(cors -&gt; cors.configurationSource(corsConfigurationSource()))&#10;            .authorizeHttpRequests(auth -&gt; auth&#10;                .anyRequest().permitAll()&#10;            )&#10;            .oauth2Login(oauth2 -&gt; oauth2&#10;                .successHandler(oAuth2SuccessHandler())&#10;                .failureUrl(&quot;http://localhost:3001/login?error=oauth_failed&quot;)&#10;            );&#10;        &#10;        return http.build();&#10;    }&#10;&#10;    @Bean&#10;    public CorsConfigurationSource corsConfigurationSource() {&#10;        CorsConfiguration configuration = new CorsConfiguration();&#10;        configuration.setAllowedOriginPatterns(Arrays.asList(&quot;*&quot;)); // Permitir todos los orígenes para desarrollo&#10;        configuration.setAllowedOrigins(Arrays.asList(&quot;http://localhost:3000&quot;, &quot;http://localhost:3001&quot;, &quot;https://accounts.google.com&quot;));&#10;        configuration.setAllowedMethods(Arrays.asList(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;, &quot;HEAD&quot;));&#10;        configuration.setAllowedHeaders(Arrays.asList(&quot;*&quot;));&#10;        configuration.setAllowCredentials(true);&#10;        configuration.setExposedHeaders(Arrays.asList(&quot;Authorization&quot;, &quot;Content-Type&quot;));&#10;        configuration.setMaxAge(3600L); // Cache preflight por 1 hora&#10;&#10;        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();&#10;        source.registerCorsConfiguration(&quot;/**&quot;, configuration);&#10;        return source;&#10;    }&#10;&#10;    @Bean&#10;    public AuthenticationSuccessHandler oAuth2SuccessHandler() {&#10;        return new AuthenticationSuccessHandler() {&#10;            @Override&#10;            public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {&#10;                System.out.println(&quot;=== OAuth2 Success Handler Called ===&quot;);&#10;                System.out.println(&quot;Authentication type: &quot; + authentication.getClass().getSimpleName());&#10;                &#10;                if (authentication instanceof OAuth2AuthenticationToken oauthToken) {&#10;                    OAuth2User oauth2User = oauthToken.getPrincipal();&#10;                    String email = oauth2User.getAttribute(&quot;email&quot;);&#10;                    String nombre = oauth2User.getAttribute(&quot;name&quot;);&#10;                    &#10;                    System.out.println(&quot;OAuth2 User Email: &quot; + email);&#10;                    System.out.println(&quot;OAuth2 User Name: &quot; + nombre);&#10;                    &#10;                    Usuario usuario = usuarioService.findAll().stream()&#10;                        .filter(u -&gt; u.getCorreo().equalsIgnoreCase(email))&#10;                        .findFirst()&#10;                        .orElseGet(() -&gt; {&#10;                            System.out.println(&quot;Creating new user for email: &quot; + email);&#10;                            Usuario nuevo = new Usuario();&#10;                            nuevo.setCorreo(email);&#10;                            nuevo.setNombre(nombre);&#10;                            nuevo.setRol(&quot;USER&quot;);&#10;                            nuevo.setPassword(&quot;&quot;);&#10;                            return usuarioService.save(nuevo);&#10;                        });&#10;                    &#10;                    System.out.println(&quot;User found/created: &quot; + usuario.getCorreo() + &quot; with role: &quot; + usuario.getRol());&#10;                    &#10;                    Map&lt;String, String&gt; tokens = authService.generateTokens(usuario);&#10;                    String jwt = tokens.get(&quot;token&quot;);&#10;                    String refreshToken = tokens.get(&quot;refreshToken&quot;);&#10;                    &#10;                    System.out.println(&quot;JWT generated: &quot; + (jwt != null ? &quot;YES&quot; : &quot;NO&quot;));&#10;                    System.out.println(&quot;RefreshToken generated: &quot; + (refreshToken != null ? &quot;YES&quot; : &quot;NO&quot;));&#10;                    &#10;                    // Set cookies for JWT and RefreshToken&#10;                    jakarta.servlet.http.Cookie jwtCookie = new jakarta.servlet.http.Cookie(&quot;jwt&quot;, jwt);&#10;                    jwtCookie.setPath(&quot;/&quot;);&#10;                    jwtCookie.setHttpOnly(true);&#10;&#10;                    jakarta.servlet.http.Cookie refreshCookie = new jakarta.servlet.http.Cookie(&quot;refreshToken&quot;, refreshToken);&#10;                    refreshCookie.setPath(&quot;/&quot;);&#10;                    refreshCookie.setHttpOnly(true);&#10;                    refreshCookie.setMaxAge(60 * 60 * 24 * 7); // 7 días&#10;                    refreshCookie.setHttpOnly(true);&#10;                    System.out.println(&quot;Redirecting to: &quot; + redirectUrl);&#10;&#10;                    response.sendRedirect(redirectUrl);&#10;                    String redirectUrl = &quot;http://localhost:3001/dashboard&quot;;&#10;                    response.sendRedirect(&quot;http://localhost:3001/login?error=oauth_failed&quot;);&#10;                }&#10;            }&#10;        };&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.empresa.erp.config;&#10;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.security.config.annotation.web.builders.HttpSecurity;&#10;import org.springframework.security.web.SecurityFilterChain;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;&#10;import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;&#10;import org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl;&#10;import org.springframework.security.access.hierarchicalroles.RoleHierarchy;&#10;import org.springframework.http.HttpMethod;&#10;import com.empresa.erp.config.RateLimitFilter;&#10;import org.springframework.web.cors.CorsConfiguration;&#10;import org.springframework.web.cors.CorsConfigurationSource;&#10;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;&#10;import java.util.Arrays;&#10;import org.springframework.security.web.authentication.AuthenticationSuccessHandler;&#10;import org.springframework.security.oauth2.core.user.OAuth2User;&#10;import org.springframework.security.oauth2.client.authentication.OAuth2AuthenticationToken;&#10;import org.springframework.security.core.Authentication;&#10;import jakarta.servlet.http.HttpServletRequest;&#10;import jakarta.servlet.http.HttpServletResponse;&#10;import jakarta.servlet.ServletException;&#10;import java.io.IOException;&#10;import com.empresa.erp.services.AuthService;&#10;import com.empresa.erp.services.UsuarioService;&#10;import com.empresa.erp.models.Usuario;&#10;import java.util.Map;&#10;import jakarta.servlet.Filter;&#10;import jakarta.servlet.FilterChain;&#10;import jakarta.servlet.http.HttpSession;&#10;import org.springframework.core.annotation.Order;&#10;import org.springframework.web.filter.OncePerRequestFilter;&#10;import org.springframework.security.web.AuthenticationEntryPoint;&#10;import org.springframework.security.web.access.AccessDeniedHandler;&#10;import org.springframework.security.web.access.AccessDeniedHandlerImpl;&#10;import org.springframework.security.web.authentication.HttpStatusEntryPoint;&#10;import org.springframework.http.HttpStatus;&#10;import jakarta.servlet.http.Cookie;&#10;&#10;@Configuration&#10;@EnableMethodSecurity&#10;public class SecurityConfig {&#10;&#10;    @Autowired&#10;    private JwtAuthenticationFilter jwtAuthenticationFilter;&#10;&#10;    @Autowired&#10;    private RateLimitFilter rateLimitFilter;&#10;&#10;    @Autowired&#10;    private AuthService authService;&#10;&#10;    @Autowired&#10;    private UsuarioService usuarioService;&#10;&#10;    @Bean&#10;    public RoleHierarchy roleHierarchy() {&#10;        RoleHierarchyImpl roleHierarchy = new RoleHierarchyImpl();&#10;        // ADMIN &gt; SUPERVISOR &gt; USER&#10;        roleHierarchy.setHierarchy(&quot;ROLE_ADMIN &gt; ROLE_SUPERVISOR \n ROLE_SUPERVISOR &gt; ROLE_USER&quot;);&#10;        return roleHierarchy;&#10;    }&#10;&#10;    @Bean&#10;    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {&#10;        http&#10;            .csrf(csrf -&gt; csrf.disable())&#10;            .cors(cors -&gt; cors.configurationSource(corsConfigurationSource()))&#10;            .authorizeHttpRequests(auth -&gt; auth&#10;                .requestMatchers(&quot;/&quot;).permitAll()&#10;                .requestMatchers(&quot;/api&quot;).permitAll()&#10;                .requestMatchers(&quot;/api/auth/**&quot;).permitAll()&#10;                .requestMatchers(&quot;/oauth2/**&quot;).permitAll()&#10;                .requestMatchers(&quot;/login/oauth2/code/**&quot;).permitAll()&#10;                .requestMatchers(&quot;/oauth/**&quot;).permitAll()&#10;                .requestMatchers(&quot;/api/test/**&quot;).permitAll()&#10;                .requestMatchers(&quot;/api/files/**&quot;).permitAll() // &lt;-- permite imágenes públicas&#10;                .requestMatchers(&quot;/api/compras/test&quot;).permitAll() // &lt;-- endpoint de prueba público&#10;                .requestMatchers(&quot;/api/compras/test-simple&quot;).permitAll() // &lt;-- endpoint de prueba simple&#10;                .requestMatchers(&quot;/api/compras/diagnostico&quot;).permitAll() // &lt;-- endpoint de diagnóstico público&#10;                .requestMatchers(&quot;/api/compras/demo&quot;).permitAll() // &lt;-- endpoint demo completamente público&#10;                .requestMatchers(&quot;/api/compras/public&quot;).authenticated() // &lt;-- endpoint público temporal&#10;                .requestMatchers(&quot;/api/usuarios/**&quot;).hasRole(&quot;ADMIN&quot;)&#10;                .requestMatchers(&quot;/api/reportes/**&quot;).hasAnyRole(&quot;ADMIN&quot;, &quot;SUPERVISOR&quot;)&#10;                .requestMatchers(HttpMethod.GET, &quot;/api/productos/**&quot;).hasAnyRole(&quot;ADMIN&quot;, &quot;SUPERVISOR&quot;, &quot;USER&quot;)&#10;                .requestMatchers(HttpMethod.POST, &quot;/api/productos/**&quot;).hasRole(&quot;ADMIN&quot;)&#10;                .requestMatchers(HttpMethod.PUT, &quot;/api/productos/**&quot;).hasRole(&quot;ADMIN&quot;)&#10;                .requestMatchers(HttpMethod.DELETE, &quot;/api/productos/**&quot;).hasRole(&quot;ADMIN&quot;)&#10;                .requestMatchers(HttpMethod.GET, &quot;/api/clientes/**&quot;).hasAnyRole(&quot;ADMIN&quot;, &quot;SUPERVISOR&quot;, &quot;USER&quot;)&#10;                .requestMatchers(HttpMethod.POST, &quot;/api/clientes/**&quot;).hasAnyRole(&quot;ADMIN&quot;, &quot;SUPERVISOR&quot;)&#10;                .requestMatchers(HttpMethod.PUT, &quot;/api/clientes/**&quot;).hasAnyRole(&quot;ADMIN&quot;, &quot;SUPERVISOR&quot;)&#10;                .requestMatchers(HttpMethod.DELETE, &quot;/api/clientes/**&quot;).hasAnyRole(&quot;ADMIN&quot;, &quot;SUPERVISOR&quot;)&#10;                .requestMatchers(HttpMethod.GET, &quot;/api/pedidos/**&quot;).hasAnyRole(&quot;ADMIN&quot;, &quot;SUPERVISOR&quot;, &quot;USER&quot;)&#10;                .requestMatchers(HttpMethod.POST, &quot;/api/pedidos/**&quot;).hasAnyRole(&quot;ADMIN&quot;, &quot;SUPERVISOR&quot;)&#10;                .requestMatchers(HttpMethod.PUT, &quot;/api/pedidos/**&quot;).hasAnyRole(&quot;ADMIN&quot;, &quot;SUPERVISOR&quot;)&#10;                .requestMatchers(HttpMethod.DELETE, &quot;/api/pedidos/**&quot;).hasAnyRole(&quot;ADMIN&quot;, &quot;SUPERVISOR&quot;)&#10;                .requestMatchers(HttpMethod.GET, &quot;/api/proveedores/**&quot;).hasAnyRole(&quot;ADMIN&quot;, &quot;SUPERVISOR&quot;)&#10;                .requestMatchers(HttpMethod.POST, &quot;/api/proveedores/**&quot;).hasRole(&quot;ADMIN&quot;)&#10;                .requestMatchers(HttpMethod.PUT, &quot;/api/proveedores/**&quot;).hasRole(&quot;ADMIN&quot;)&#10;                .requestMatchers(HttpMethod.DELETE, &quot;/api/proveedores/**&quot;).hasRole(&quot;ADMIN&quot;)&#10;                .requestMatchers(HttpMethod.GET, &quot;/api/compras/**&quot;).hasAnyRole(&quot;ADMIN&quot;, &quot;SUPERVISOR&quot;)&#10;                .requestMatchers(HttpMethod.POST, &quot;/api/compras/**&quot;).hasRole(&quot;ADMIN&quot;)&#10;                .requestMatchers(HttpMethod.PUT, &quot;/api/compras/**&quot;).hasRole(&quot;ADMIN&quot;)&#10;                .requestMatchers(HttpMethod.DELETE, &quot;/api/compras/**&quot;).hasRole(&quot;ADMIN&quot;)&#10;                .requestMatchers(HttpMethod.GET, &quot;/api/movimientos-inventario/**&quot;).hasAnyRole(&quot;ADMIN&quot;, &quot;SUPERVISOR&quot;)&#10;                .requestMatchers(HttpMethod.POST, &quot;/api/movimientos-inventario/**&quot;).hasRole(&quot;ADMIN&quot;)&#10;                .requestMatchers(HttpMethod.PUT, &quot;/api/movimientos-inventario/**&quot;).hasRole(&quot;ADMIN&quot;)&#10;                .requestMatchers(HttpMethod.DELETE, &quot;/api/movimientos-inventario/**&quot;).hasRole(&quot;ADMIN&quot;)&#10;                .requestMatchers(&quot;/api/auth/login&quot;, &quot;/api/auth/refresh&quot;, &quot;/api/auth/verify-recaptcha&quot;).permitAll()&#10;                .requestMatchers(&quot;/api/auth/me&quot;).authenticated()&#10;                .anyRequest().authenticated()&#10;            )&#10;            .logout(logout -&gt; logout&#10;                .logoutUrl(&quot;/logout&quot;)&#10;                .logoutSuccessHandler((request, response, authentication) -&gt; {&#10;                    // Invalida la sesión&#10;                    if (request.getSession(false) != null) {&#10;                        request.getSession(false).invalidate();&#10;                    }&#10;                    // Borra la cookie JSESSIONID&#10;                    jakarta.servlet.http.Cookie cookie = new jakarta.servlet.http.Cookie(&quot;JSESSIONID&quot;, null);&#10;                    cookie.setPath(&quot;/&quot;);&#10;                    cookie.setHttpOnly(true);&#10;                    cookie.setMaxAge(0);&#10;                    response.addCookie(cookie);&#10;&#10;                    response.setStatus(HttpStatus.OK.value());&#10;                    response.setContentType(&quot;application/json&quot;);&#10;                    response.getWriter().write(&quot;{\&quot;message\&quot;: \&quot;Logout exitoso\&quot;}&quot;);&#10;                })&#10;            )&#10;            .oauth2Login(oauth2 -&gt; oauth2&#10;                .successHandler(oAuth2SuccessHandler())&#10;                .failureUrl(&quot;http://localhost:3001/login?error=oauth_failed&quot;)&#10;            )&#10;            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)&#10;            .addFilterBefore(rateLimitFilter, JwtAuthenticationFilter.class)&#10;            .exceptionHandling(exception -&gt; exception&#10;                .authenticationEntryPoint(new HttpStatusEntryPoint(HttpStatus.UNAUTHORIZED))&#10;                .accessDeniedHandler((request, response, accessDeniedException) -&gt; {&#10;                    response.setStatus(HttpStatus.FORBIDDEN.value());&#10;                    response.setContentType(&quot;application/json&quot;);&#10;                    response.getWriter().write(&quot;{\&quot;error\&quot;: \&quot;Forbidden\&quot;}&quot;);&#10;                })&#10;            );&#10;        return http.build();&#10;    }&#10;&#10;    @Bean&#10;    public SecurityFilterChain oauth2FilterChain(HttpSecurity http) throws Exception {&#10;        http&#10;            .securityMatcher(&quot;/oauth2/**&quot;, &quot;/login/oauth2/**&quot;)&#10;            .csrf(csrf -&gt; csrf.disable())&#10;            .cors(cors -&gt; cors.configurationSource(corsConfigurationSource()))&#10;            .authorizeHttpRequests(auth -&gt; auth&#10;                .anyRequest().permitAll()&#10;            )&#10;            .oauth2Login(oauth2 -&gt; oauth2&#10;                .successHandler(oAuth2SuccessHandler())&#10;                .failureUrl(&quot;http://localhost:3001/login?error=oauth_failed&quot;)&#10;            );&#10;        &#10;        return http.build();&#10;    }&#10;&#10;    @Bean&#10;    public CorsConfigurationSource corsConfigurationSource() {&#10;        CorsConfiguration configuration = new CorsConfiguration();&#10;        configuration.setAllowedOriginPatterns(Arrays.asList(&quot;*&quot;)); // Permitir todos los orígenes para desarrollo&#10;        configuration.setAllowedOrigins(Arrays.asList(&quot;http://localhost:3000&quot;, &quot;http://localhost:3001&quot;, &quot;https://accounts.google.com&quot;));&#10;        configuration.setAllowedMethods(Arrays.asList(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;, &quot;HEAD&quot;));&#10;        configuration.setAllowedHeaders(Arrays.asList(&quot;*&quot;));&#10;        configuration.setAllowCredentials(true);&#10;        configuration.setExposedHeaders(Arrays.asList(&quot;Authorization&quot;, &quot;Content-Type&quot;));&#10;        configuration.setMaxAge(3600L); // Cache preflight por 1 hora&#10;&#10;        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();&#10;        source.registerCorsConfiguration(&quot;/**&quot;, configuration);&#10;        return source;&#10;    }&#10;&#10;    @Bean&#10;    public AuthenticationSuccessHandler oAuth2SuccessHandler() {&#10;        return new AuthenticationSuccessHandler() {&#10;            @Override&#10;            public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {&#10;                System.out.println(&quot;=== OAuth2 Success Handler Called ===&quot;);&#10;                System.out.println(&quot;Authentication type: &quot; + authentication.getClass().getSimpleName());&#10;                &#10;                if (authentication instanceof OAuth2AuthenticationToken oauthToken) {&#10;                    OAuth2User oauth2User = oauthToken.getPrincipal();&#10;                    String email = oauth2User.getAttribute(&quot;email&quot;);&#10;                    String nombre = oauth2User.getAttribute(&quot;name&quot;);&#10;                    &#10;                    System.out.println(&quot;OAuth2 User Email: &quot; + email);&#10;                    System.out.println(&quot;OAuth2 User Name: &quot; + nombre);&#10;                    &#10;                    Usuario usuario = usuarioService.findAll().stream()&#10;                        .filter(u -&gt; u.getCorreo().equalsIgnoreCase(email))&#10;                        .findFirst()&#10;                        .orElseGet(() -&gt; {&#10;                            System.out.println(&quot;Creating new user for email: &quot; + email);&#10;                            Usuario nuevo = new Usuario();&#10;                            nuevo.setCorreo(email);&#10;                            nuevo.setNombre(nombre);&#10;                            nuevo.setRol(&quot;USER&quot;);&#10;                            nuevo.setPassword(&quot;&quot;);&#10;                            return usuarioService.save(nuevo);&#10;                        });&#10;                    &#10;                    System.out.println(&quot;User found/created: &quot; + usuario.getCorreo() + &quot; with role: &quot; + usuario.getRol());&#10;                    &#10;                    Map&lt;String, String&gt; tokens = authService.generateTokens(usuario);&#10;                    String jwt = tokens.get(&quot;token&quot;);&#10;                    String refreshToken = tokens.get(&quot;refreshToken&quot;);&#10;                    &#10;                    System.out.println(&quot;JWT generated: &quot; + (jwt != null ? &quot;YES&quot; : &quot;NO&quot;));&#10;                    System.out.println(&quot;RefreshToken generated: &quot; + (refreshToken != null ? &quot;YES&quot; : &quot;NO&quot;));&#10;                    &#10;                    // Set cookies for JWT and RefreshToken con configuración corregida&#10;                    jakarta.servlet.http.Cookie jwtCookie = new jakarta.servlet.http.Cookie(&quot;jwt&quot;, jwt);&#10;                    jwtCookie.setPath(&quot;/&quot;);&#10;                    jwtCookie.setHttpOnly(false); // Permitir acceso desde JavaScript&#10;                    jwtCookie.setSecure(false); // Para localhost HTTP&#10;                    jwtCookie.setDomain(&quot;localhost&quot;); // Configurar dominio específicamente&#10;                    jwtCookie.setMaxAge(60 * 60 * 24); // 1 día&#10;                    response.addCookie(jwtCookie);&#10;&#10;                    jakarta.servlet.http.Cookie refreshCookie = new jakarta.servlet.http.Cookie(&quot;refreshToken&quot;, refreshToken);&#10;                    refreshCookie.setPath(&quot;/&quot;);&#10;                    refreshCookie.setHttpOnly(false); // Permitir acceso desde JavaScript&#10;                    refreshCookie.setSecure(false); // Para localhost HTTP&#10;                    refreshCookie.setDomain(&quot;localhost&quot;); // Configurar dominio específicamente&#10;                    refreshCookie.setMaxAge(60 * 60 * 24 * 7); // 7 días&#10;                    response.addCookie(refreshCookie);&#10;&#10;                    // También agregar el token como parámetro en la URL de redirección&#10;                    String redirectUrl = &quot;http://localhost:3001/dashboard?token=&quot; + jwt + &quot;&amp;refreshToken=&quot; + refreshToken;&#10;                    System.out.println(&quot;Redirecting to: &quot; + redirectUrl);&#10;&#10;                    response.sendRedirect(redirectUrl);&#10;                } else {&#10;                    System.out.println(&quot;Authentication is not OAuth2AuthenticationToken: &quot; + authentication.getClass().getName());&#10;                    response.sendRedirect(&quot;http://localhost:3001/login?error=oauth_failed&quot;);&#10;                }&#10;            }&#10;        };&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/main/java/com/empresa/erp/controllers/FileUploadController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/main/java/com/empresa/erp/controllers/FileUploadController.java" />
              <option name="originalContent" value="package com.empresa.erp.controllers;&#10;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;import org.springframework.web.multipart.MultipartFile;&#10;import org.springframework.core.io.Resource;&#10;import org.springframework.core.io.UrlResource;&#10;import org.springframework.http.HttpHeaders;&#10;import org.springframework.http.MediaType;&#10;&#10;import java.io.IOException;&#10;import java.nio.file.Files;&#10;import java.nio.file.Path;&#10;import java.nio.file.Paths;&#10;import java.nio.file.StandardCopyOption;&#10;import java.util.Map;&#10;import java.util.UUID;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/files&quot;)&#10;@CrossOrigin(origins = &quot;*&quot;)&#10;public class FileUploadController {&#10;    &#10;    private final Path uploadPath = Paths.get(&quot;C:/ERP_SENA_Final/backend/uploads&quot;);&#10;    private final Path clientesPath = Paths.get(&quot;C:/ERP_SENA_Final/backend/uploads/clientes&quot;);&#10;    private final Path usuariosPath = Paths.get(&quot;C:/ERP_SENA_Final/backend/uploads/usuarios&quot;);&#10;    private final Path productosPath = Paths.get(&quot;C:/ERP_SENA_Final/backend/uploads/productos&quot;);&#10;    &#10;    public FileUploadController() {&#10;        try {&#10;            Files.createDirectories(uploadPath);&#10;            Files.createDirectories(clientesPath);&#10;            Files.createDirectories(usuariosPath);&#10;            Files.createDirectories(productosPath);&#10;        } catch (IOException e) {&#10;            throw new RuntimeException(&quot;No se pudo crear el directorio de uploads&quot;, e);&#10;        }&#10;    }&#10;    &#10;    @PostMapping(&quot;/upload&quot;)&#10;    public ResponseEntity&lt;?&gt; uploadFile(@RequestParam(&quot;file&quot;) MultipartFile file) {&#10;        try {&#10;            // Validar tipo de archivo&#10;            String contentType = file.getContentType();&#10;            if (contentType == null || !contentType.startsWith(&quot;image/&quot;)) {&#10;                return ResponseEntity.badRequest().body(&quot;Solo se permiten archivos de imagen&quot;);&#10;            }&#10;            &#10;            // Validar tamaño (máximo 5MB)&#10;            if (file.getSize() &gt; 5 * 1024 * 1024) {&#10;                return ResponseEntity.badRequest().body(&quot;El archivo es demasiado grande. Máximo 5MB&quot;);&#10;            }&#10;            &#10;            // Generar nombre único&#10;            String originalFilename = file.getOriginalFilename();&#10;            String extension = &quot;&quot;;&#10;            if (originalFilename != null &amp;&amp; originalFilename.contains(&quot;.&quot;)) {&#10;                extension = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));&#10;            }&#10;            String filename = UUID.randomUUID().toString() + extension;&#10;            &#10;            // Guardar archivo&#10;            Path filePath = uploadPath.resolve(filename);&#10;            Files.copy(file.getInputStream(), filePath, StandardCopyOption.REPLACE_EXISTING);&#10;            &#10;            return ResponseEntity.ok().body(Map.of(&#10;                &quot;filename&quot;, filename,&#10;                &quot;originalName&quot;, originalFilename,&#10;                &quot;size&quot;, file.getSize(),&#10;                &quot;url&quot;, &quot;/api/files/&quot; + filename&#10;            ));&#10;            &#10;        } catch (IOException e) {&#10;            return ResponseEntity.internalServerError().body(&quot;Error al subir el archivo: &quot; + e.getMessage());&#10;        }&#10;    }&#10;    &#10;    @PostMapping(&quot;/upload/cliente&quot;)&#10;    public ResponseEntity&lt;?&gt; uploadClienteImage(@RequestParam(&quot;file&quot;) MultipartFile file) {&#10;        try {&#10;            // Validar tipo de archivo&#10;            String contentType = file.getContentType();&#10;            if (contentType == null || !contentType.startsWith(&quot;image/&quot;)) {&#10;                return ResponseEntity.badRequest().body(&quot;Solo se permiten archivos de imagen&quot;);&#10;            }&#10;            &#10;            // Validar tamaño (máximo 5MB)&#10;            if (file.getSize() &gt; 5 * 1024 * 1024) {&#10;                return ResponseEntity.badRequest().body(&quot;El archivo es demasiado grande. Máximo 5MB&quot;);&#10;            }&#10;            &#10;            // Generar nombre único&#10;            String originalFilename = file.getOriginalFilename();&#10;            String extension = &quot;&quot;;&#10;            if (originalFilename != null &amp;&amp; originalFilename.contains(&quot;.&quot;)) {&#10;                extension = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));&#10;            }&#10;            String filename = &quot;cliente_&quot; + UUID.randomUUID().toString() + extension;&#10;            &#10;            // Guardar archivo en directorio de clientes&#10;            Path filePath = clientesPath.resolve(filename);&#10;            Files.copy(file.getInputStream(), filePath, StandardCopyOption.REPLACE_EXISTING);&#10;            &#10;            return ResponseEntity.ok().body(Map.of(&#10;                &quot;filename&quot;, filename,&#10;                &quot;originalName&quot;, originalFilename,&#10;                &quot;size&quot;, file.getSize(),&#10;                &quot;url&quot;, &quot;/api/files/clientes/&quot; + filename&#10;            ));&#10;            &#10;        } catch (IOException e) {&#10;            return ResponseEntity.internalServerError().body(&quot;Error al subir la imagen del cliente: &quot; + e.getMessage());&#10;        }&#10;    }&#10;    &#10;    @PostMapping(&quot;/upload/usuario&quot;)&#10;    public ResponseEntity&lt;?&gt; uploadUsuarioImage(@RequestParam(&quot;file&quot;) MultipartFile file) {&#10;        try {&#10;            // Validar tipo de archivo&#10;            String contentType = file.getContentType();&#10;            if (contentType == null || !contentType.startsWith(&quot;image/&quot;)) {&#10;                return ResponseEntity.badRequest().body(&quot;Solo se permiten archivos de imagen&quot;);&#10;            }&#10;            &#10;            // Validar tamaño (máximo 5MB)&#10;            if (file.getSize() &gt; 5 * 1024 * 1024) {&#10;                return ResponseEntity.badRequest().body(&quot;El archivo es demasiado grande. Máximo 5MB&quot;);&#10;            }&#10;            &#10;            // Generar nombre único&#10;            String originalFilename = file.getOriginalFilename();&#10;            String extension = &quot;&quot;;&#10;            if (originalFilename != null &amp;&amp; originalFilename.contains(&quot;.&quot;)) {&#10;                extension = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));&#10;            }&#10;            String filename = &quot;usuario_&quot; + UUID.randomUUID().toString() + extension;&#10;            &#10;            // Guardar archivo en directorio de usuarios&#10;            Path filePath = usuariosPath.resolve(filename);&#10;            Files.copy(file.getInputStream(), filePath, StandardCopyOption.REPLACE_EXISTING);&#10;            &#10;            return ResponseEntity.ok().body(Map.of(&#10;                &quot;filename&quot;, filename,&#10;                &quot;originalName&quot;, originalFilename,&#10;                &quot;size&quot;, file.getSize(),&#10;                &quot;url&quot;, &quot;/api/files/usuarios/&quot; + filename&#10;            ));&#10;            &#10;        } catch (IOException e) {&#10;            return ResponseEntity.internalServerError().body(&quot;Error al subir la imagen del usuario: &quot; + e.getMessage());&#10;        }&#10;    }&#10;    &#10;    @GetMapping(&quot;/clientes/{filename:.+}&quot;)&#10;    public ResponseEntity&lt;Resource&gt; getClienteImage(@PathVariable String filename) {&#10;        try {&#10;            // Decodificar el nombre del archivo si viene codificado&#10;            String decodedFilename = java.net.URLDecoder.decode(filename, &quot;UTF-8&quot;);&#10;            &#10;            Path filePath = clientesPath.resolve(decodedFilename);&#10;            Resource resource = new UrlResource(filePath.toUri());&#10;            &#10;            if (resource.exists() &amp;&amp; resource.isReadable()) {&#10;                // Determinar el tipo MIME basado en la extensión del archivo&#10;                String contentType = determineContentType(decodedFilename);&#10;                &#10;                return ResponseEntity.ok()&#10;                    .header(HttpHeaders.CONTENT_DISPOSITION, &quot;inline; filename=\&quot;&quot; + decodedFilename + &quot;\&quot;&quot;)&#10;                    .header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)&#10;                    .header(&quot;Access-Control-Allow-Methods&quot;, &quot;GET&quot;)&#10;                    .header(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;)&#10;                    .contentType(MediaType.parseMediaType(contentType))&#10;                    .body(resource);&#10;            } else {&#10;                // Log para debugging&#10;                System.out.println(&quot;Archivo de cliente no encontrado: &quot; + decodedFilename);&#10;                System.out.println(&quot;Ruta completa: &quot; + filePath.toAbsolutePath());&#10;                return ResponseEntity.notFound()&#10;                    .header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)&#10;                    .header(&quot;Access-Control-Allow-Methods&quot;, &quot;GET&quot;)&#10;                    .header(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;)&#10;                    .build();&#10;            }&#10;        } catch (IOException e) {&#10;            System.out.println(&quot;Error accediendo al archivo de cliente: &quot; + e.getMessage());&#10;            return ResponseEntity.internalServerError()&#10;                .header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)&#10;                .header(&quot;Access-Control-Allow-Methods&quot;, &quot;GET&quot;)&#10;                .header(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;)&#10;                .build();&#10;        }&#10;    }&#10;    &#10;    @GetMapping(&quot;/usuarios/{filename:.+}&quot;)&#10;    public ResponseEntity&lt;Resource&gt; getUsuarioImage(@PathVariable String filename) {&#10;        try {&#10;            // Decodificar el nombre del archivo si viene codificado&#10;            String decodedFilename = java.net.URLDecoder.decode(filename, &quot;UTF-8&quot;);&#10;            &#10;            Path filePath = usuariosPath.resolve(decodedFilename);&#10;            Resource resource = new UrlResource(filePath.toUri());&#10;            &#10;            if (resource.exists() &amp;&amp; resource.isReadable()) {&#10;                // Determinar el tipo MIME basado en la extensión del archivo&#10;                String contentType = determineContentType(decodedFilename);&#10;                &#10;                return ResponseEntity.ok()&#10;                    .header(HttpHeaders.CONTENT_DISPOSITION, &quot;inline; filename=\&quot;&quot; + decodedFilename + &quot;\&quot;&quot;)&#10;                    .header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)&#10;                    .header(&quot;Access-Control-Allow-Methods&quot;, &quot;GET&quot;)&#10;                    .header(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;)&#10;                    .contentType(MediaType.parseMediaType(contentType))&#10;                    .body(resource);&#10;            } else {&#10;                // Log para debugging&#10;                System.out.println(&quot;Archivo de usuario no encontrado: &quot; + decodedFilename);&#10;                System.out.println(&quot;Ruta completa: &quot; + filePath.toAbsolutePath());&#10;                return ResponseEntity.notFound()&#10;                    .header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)&#10;                    .header(&quot;Access-Control-Allow-Methods&quot;, &quot;GET&quot;)&#10;                    .header(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;)&#10;                    .build();&#10;            }&#10;        } catch (IOException e) {&#10;            System.out.println(&quot;Error accediendo al archivo de usuario: &quot; + e.getMessage());&#10;            return ResponseEntity.internalServerError()&#10;                .header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)&#10;                .header(&quot;Access-Control-Allow-Methods&quot;, &quot;GET&quot;)&#10;                .header(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;)&#10;                .build();&#10;        }&#10;    }&#10;    &#10;    @GetMapping(&quot;/productos/{filename:.+}&quot;)&#10;    public ResponseEntity&lt;Resource&gt; getProductImage(@PathVariable String filename) {&#10;        try {&#10;            // Decodificar el nombre del archivo si viene codificado&#10;            String decodedFilename = java.net.URLDecoder.decode(filename, &quot;UTF-8&quot;);&#10;            &#10;            Path filePath = productosPath.resolve(decodedFilename);&#10;            Resource resource = new UrlResource(filePath.toUri());&#10;            &#10;            if (resource.exists() &amp;&amp; resource.isReadable()) {&#10;                // Determinar el tipo MIME basado en la extensión del archivo&#10;                String contentType = determineContentType(decodedFilename);&#10;                &#10;                return ResponseEntity.ok()&#10;                    .header(HttpHeaders.CONTENT_DISPOSITION, &quot;inline; filename=\&quot;&quot; + decodedFilename + &quot;\&quot;&quot;)&#10;                    .header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)&#10;                    .header(&quot;Access-Control-Allow-Methods&quot;, &quot;GET&quot;)&#10;                    .header(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;)&#10;                    .contentType(MediaType.parseMediaType(contentType))&#10;                    .body(resource);&#10;            } else {&#10;                // Log para debugging&#10;                System.out.println(&quot;Archivo no encontrado: &quot; + decodedFilename);&#10;                System.out.println(&quot;Ruta completa: &quot; + filePath.toAbsolutePath());&#10;                return ResponseEntity.notFound()&#10;                    .header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)&#10;                    .header(&quot;Access-Control-Allow-Methods&quot;, &quot;GET&quot;)&#10;                    .header(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;)&#10;                    .build();&#10;            }&#10;        } catch (IOException e) {&#10;            System.out.println(&quot;Error accediendo al archivo: &quot; + e.getMessage());&#10;            return ResponseEntity.internalServerError()&#10;                .header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)&#10;                .header(&quot;Access-Control-Allow-Methods&quot;, &quot;GET&quot;)&#10;                .header(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;)&#10;                .build();&#10;        }&#10;    }&#10;&#10;    @GetMapping(&quot;/{filename:.+}&quot;)&#10;    public ResponseEntity&lt;Resource&gt; getFile(@PathVariable String filename) {&#10;        try {&#10;            // Decodificar el nombre del archivo si viene codificado&#10;            String decodedFilename = java.net.URLDecoder.decode(filename, &quot;UTF-8&quot;);&#10;            &#10;            Path filePath = uploadPath.resolve(decodedFilename);&#10;            Resource resource = new UrlResource(filePath.toUri());&#10;            &#10;            if (resource.exists() &amp;&amp; resource.isReadable()) {&#10;                // Determinar el tipo MIME basado en la extensión del archivo&#10;                String contentType = determineContentType(decodedFilename);&#10;                &#10;                return ResponseEntity.ok()&#10;                    .header(HttpHeaders.CONTENT_DISPOSITION, &quot;inline; filename=\&quot;&quot; + decodedFilename + &quot;\&quot;&quot;)&#10;                    .header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)&#10;                    .header(&quot;Access-Control-Allow-Methods&quot;, &quot;GET&quot;)&#10;                    .header(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;)&#10;                    .contentType(MediaType.parseMediaType(contentType))&#10;                    .body(resource);&#10;            } else {&#10;                // Log para debugging&#10;                System.out.println(&quot;Archivo no encontrado: &quot; + decodedFilename);&#10;                System.out.println(&quot;Ruta completa: &quot; + filePath.toAbsolutePath());&#10;                System.out.println(&quot;Archivos en uploads:&quot;);&#10;                try {&#10;                    Files.list(uploadPath).forEach(System.out::println);&#10;                } catch (IOException e) {&#10;                    System.out.println(&quot;Error listando archivos: &quot; + e.getMessage());&#10;                }&#10;                return ResponseEntity.notFound()&#10;                    .header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)&#10;                    .header(&quot;Access-Control-Allow-Methods&quot;, &quot;GET&quot;)&#10;                    .header(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;)&#10;                    .build();&#10;            }&#10;        } catch (IOException e) {&#10;            System.out.println(&quot;Error accediendo al archivo: &quot; + e.getMessage());&#10;            return ResponseEntity.internalServerError()&#10;                .header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)&#10;                .header(&quot;Access-Control-Allow-Methods&quot;, &quot;GET&quot;)&#10;                .header(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;)&#10;                .build();&#10;        }&#10;    }&#10;    &#10;    private String determineContentType(String filename) {&#10;        String extension = &quot;&quot;;&#10;        if (filename.contains(&quot;.&quot;)) {&#10;            extension = filename.substring(filename.lastIndexOf(&quot;.&quot;)).toLowerCase();&#10;        }&#10;        &#10;        switch (extension) {&#10;            case &quot;.png&quot;:&#10;                return &quot;image/png&quot;;&#10;            case &quot;.jpg&quot;:&#10;            case &quot;.jpeg&quot;:&#10;                return &quot;image/jpeg&quot;;&#10;            case &quot;.gif&quot;:&#10;                return &quot;image/gif&quot;;&#10;            case &quot;.webp&quot;:&#10;                return &quot;image/webp&quot;;&#10;            case &quot;.bmp&quot;:&#10;                return &quot;image/bmp&quot;;&#10;            default:&#10;                return &quot;image/jpeg&quot;; // Por defecto JPEG&#10;        }&#10;    }&#10;    &#10;    @DeleteMapping(&quot;/{filename}&quot;)&#10;    public ResponseEntity&lt;?&gt; deleteFile(@PathVariable String filename) {&#10;        try {&#10;            Path filePath = uploadPath.resolve(filename);&#10;            if (Files.exists(filePath)) {&#10;                Files.delete(filePath);&#10;                return ResponseEntity.ok().body(&quot;Archivo eliminado correctamente&quot;);&#10;            } else {&#10;                return ResponseEntity.notFound().build();&#10;            }&#10;        } catch (IOException e) {&#10;            return ResponseEntity.internalServerError().body(&quot;Error al eliminar el archivo: &quot; + e.getMessage());&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.empresa.erp.controllers;&#13;&#10;&#13;&#10;import org.springframework.http.ResponseEntity;&#13;&#10;import org.springframework.web.bind.annotation.*;&#13;&#10;import org.springframework.web.multipart.MultipartFile;&#13;&#10;import org.springframework.core.io.Resource;&#13;&#10;import org.springframework.core.io.UrlResource;&#13;&#10;import org.springframework.http.HttpHeaders;&#13;&#10;import org.springframework.http.MediaType;&#13;&#10;&#13;&#10;import java.io.IOException;&#13;&#10;import java.nio.file.Files;&#13;&#10;import java.nio.file.Path;&#13;&#10;import java.nio.file.Paths;&#13;&#10;import java.nio.file.StandardCopyOption;&#13;&#10;import java.util.Map;&#13;&#10;import java.util.UUID;&#13;&#10;&#13;&#10;@RestController&#13;&#10;@RequestMapping(&quot;/api/files&quot;)&#13;&#10;@CrossOrigin(origins = &quot;*&quot;)&#13;&#10;public class FileUploadController {&#13;&#10;    &#13;&#10;    private final Path uploadPath = Paths.get(&quot;C:/ERP_SENA_Final/backend/uploads&quot;);&#13;&#10;    private final Path clientesPath = Paths.get(&quot;C:/ERP_SENA_Final/backend/uploads/clientes&quot;);&#13;&#10;    private final Path usuariosPath = Paths.get(&quot;C:/ERP_SENA_Final/backend/uploads/usuarios&quot;);&#13;&#10;    private final Path productosPath = Paths.get(&quot;C:/ERP_SENA_Final/backend/uploads/productos&quot;);&#13;&#10;    &#13;&#10;    public FileUploadController() {&#13;&#10;        try {&#13;&#10;            Files.createDirectories(uploadPath);&#13;&#10;            Files.createDirectories(clientesPath);&#13;&#10;            Files.createDirectories(usuariosPath);&#13;&#10;            Files.createDirectories(productosPath);&#13;&#10;        } catch (IOException e) {&#13;&#10;            throw new RuntimeException(&quot;No se pudo crear el directorio de uploads&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;    &#13;&#10;    @PostMapping(&quot;/upload&quot;)&#13;&#10;    public ResponseEntity&lt;?&gt; uploadFile(@RequestParam(&quot;file&quot;) MultipartFile file) {&#13;&#10;        try {&#13;&#10;            // Validar tipo de archivo&#13;&#10;            String contentType = file.getContentType();&#13;&#10;            if (contentType == null || !contentType.startsWith(&quot;image/&quot;)) {&#13;&#10;                return ResponseEntity.badRequest().body(&quot;Solo se permiten archivos de imagen&quot;);&#13;&#10;            }&#13;&#10;            &#13;&#10;            // Validar tamaño (máximo 5MB)&#13;&#10;            if (file.getSize() &gt; 5 * 1024 * 1024) {&#13;&#10;                return ResponseEntity.badRequest().body(&quot;El archivo es demasiado grande. Máximo 5MB&quot;);&#13;&#10;            }&#13;&#10;            &#13;&#10;            // Generar nombre único&#13;&#10;            String originalFilename = file.getOriginalFilename();&#13;&#10;            String extension = &quot;&quot;;&#13;&#10;            if (originalFilename != null &amp;&amp; originalFilename.contains(&quot;.&quot;)) {&#13;&#10;                extension = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));&#13;&#10;            }&#13;&#10;            String filename = UUID.randomUUID().toString() + extension;&#13;&#10;            &#13;&#10;            // Guardar archivo&#13;&#10;            Path filePath = uploadPath.resolve(filename);&#13;&#10;            Files.copy(file.getInputStream(), filePath, StandardCopyOption.REPLACE_EXISTING);&#13;&#10;            &#13;&#10;            return ResponseEntity.ok().body(Map.of(&#13;&#10;                &quot;filename&quot;, filename,&#13;&#10;                &quot;originalName&quot;, originalFilename,&#13;&#10;                &quot;size&quot;, file.getSize(),&#13;&#10;                &quot;url&quot;, &quot;/api/files/&quot; + filename&#13;&#10;            ));&#13;&#10;            &#13;&#10;        } catch (IOException e) {&#13;&#10;            return ResponseEntity.internalServerError().body(&quot;Error al subir el archivo: &quot; + e.getMessage());&#13;&#10;        }&#13;&#10;    }&#13;&#10;    &#13;&#10;    @PostMapping(&quot;/upload/cliente&quot;)&#13;&#10;    public ResponseEntity&lt;?&gt; uploadClienteImage(@RequestParam(&quot;file&quot;) MultipartFile file) {&#13;&#10;        try {&#13;&#10;            // Validar tipo de archivo&#13;&#10;            String contentType = file.getContentType();&#13;&#10;            if (contentType == null || !contentType.startsWith(&quot;image/&quot;)) {&#13;&#10;                return ResponseEntity.badRequest().body(&quot;Solo se permiten archivos de imagen&quot;);&#13;&#10;            }&#13;&#10;            &#13;&#10;            // Validar tamaño (máximo 5MB)&#13;&#10;            if (file.getSize() &gt; 5 * 1024 * 1024) {&#13;&#10;                return ResponseEntity.badRequest().body(&quot;El archivo es demasiado grande. Máximo 5MB&quot;);&#13;&#10;            }&#13;&#10;            &#13;&#10;            // Generar nombre único&#13;&#10;            String originalFilename = file.getOriginalFilename();&#13;&#10;            String extension = &quot;&quot;;&#13;&#10;            if (originalFilename != null &amp;&amp; originalFilename.contains(&quot;.&quot;)) {&#13;&#10;                extension = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));&#13;&#10;            }&#13;&#10;            String filename = &quot;cliente_&quot; + UUID.randomUUID().toString() + extension;&#13;&#10;            &#13;&#10;            // Guardar archivo en directorio de clientes&#13;&#10;            Path filePath = clientesPath.resolve(filename);&#13;&#10;            Files.copy(file.getInputStream(), filePath, StandardCopyOption.REPLACE_EXISTING);&#13;&#10;            &#13;&#10;            return ResponseEntity.ok().body(Map.of(&#13;&#10;                &quot;filename&quot;, filename,&#13;&#10;                &quot;originalName&quot;, originalFilename,&#13;&#10;                &quot;size&quot;, file.getSize(),&#13;&#10;                &quot;url&quot;, &quot;/api/files/clientes/&quot; + filename&#13;&#10;            ));&#13;&#10;            &#13;&#10;        } catch (IOException e) {&#13;&#10;            return ResponseEntity.internalServerError().body(&quot;Error al subir la imagen del cliente: &quot; + e.getMessage());&#13;&#10;        }&#13;&#10;    }&#13;&#10;    &#13;&#10;    @PostMapping(&quot;/upload/usuario&quot;)&#13;&#10;    public ResponseEntity&lt;?&gt; uploadUsuarioImage(@RequestParam(&quot;file&quot;) MultipartFile file) {&#13;&#10;        try {&#13;&#10;            // Validar tipo de archivo&#13;&#10;            String contentType = file.getContentType();&#13;&#10;            if (contentType == null || !contentType.startsWith(&quot;image/&quot;)) {&#13;&#10;                return ResponseEntity.badRequest().body(&quot;Solo se permiten archivos de imagen&quot;);&#13;&#10;            }&#13;&#10;            &#13;&#10;            // Validar tamaño (máximo 5MB)&#13;&#10;            if (file.getSize() &gt; 5 * 1024 * 1024) {&#13;&#10;                return ResponseEntity.badRequest().body(&quot;El archivo es demasiado grande. Máximo 5MB&quot;);&#13;&#10;            }&#13;&#10;            &#13;&#10;            // Generar nombre único&#13;&#10;            String originalFilename = file.getOriginalFilename();&#13;&#10;            String extension = &quot;&quot;;&#13;&#10;            if (originalFilename != null &amp;&amp; originalFilename.contains(&quot;.&quot;)) {&#13;&#10;                extension = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));&#13;&#10;            }&#13;&#10;            String filename = &quot;usuario_&quot; + UUID.randomUUID().toString() + extension;&#13;&#10;            &#13;&#10;            // Guardar archivo en directorio de usuarios&#13;&#10;            Path filePath = usuariosPath.resolve(filename);&#13;&#10;            Files.copy(file.getInputStream(), filePath, StandardCopyOption.REPLACE_EXISTING);&#13;&#10;            &#13;&#10;            return ResponseEntity.ok().body(Map.of(&#13;&#10;                &quot;filename&quot;, filename,&#13;&#10;                &quot;originalName&quot;, originalFilename,&#13;&#10;                &quot;size&quot;, file.getSize(),&#13;&#10;                &quot;url&quot;, &quot;/api/files/usuarios/&quot; + filename&#13;&#10;            ));&#13;&#10;            &#13;&#10;        } catch (IOException e) {&#13;&#10;            return ResponseEntity.internalServerError().body(&quot;Error al subir la imagen del usuario: &quot; + e.getMessage());&#13;&#10;        }&#13;&#10;    }&#13;&#10;    &#13;&#10;    @GetMapping(&quot;/clientes/{filename:.+}&quot;)&#13;&#10;    public ResponseEntity&lt;Resource&gt; getClienteImage(@PathVariable String filename) {&#13;&#10;        try {&#13;&#10;            // Decodificar el nombre del archivo si viene codificado&#13;&#10;            String decodedFilename = java.net.URLDecoder.decode(filename, &quot;UTF-8&quot;);&#13;&#10;            &#13;&#10;            Path filePath = clientesPath.resolve(decodedFilename);&#13;&#10;            Resource resource = new UrlResource(filePath.toUri());&#13;&#10;            &#13;&#10;            if (resource.exists() &amp;&amp; resource.isReadable()) {&#13;&#10;                // Determinar el tipo MIME basado en la extensión del archivo&#13;&#10;                String contentType = determineContentType(decodedFilename);&#13;&#10;                &#13;&#10;                return ResponseEntity.ok()&#13;&#10;                    .header(HttpHeaders.CONTENT_DISPOSITION, &quot;inline; filename=\&quot;&quot; + decodedFilename + &quot;\&quot;&quot;)&#13;&#10;                    .header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)&#13;&#10;                    .header(&quot;Access-Control-Allow-Methods&quot;, &quot;GET&quot;)&#13;&#10;                    .header(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;)&#13;&#10;                    .contentType(MediaType.parseMediaType(contentType))&#13;&#10;                    .body(resource);&#13;&#10;            } else {&#13;&#10;                // Log para debugging&#13;&#10;                System.out.println(&quot;Archivo de cliente no encontrado: &quot; + decodedFilename);&#13;&#10;                System.out.println(&quot;Ruta completa: &quot; + filePath.toAbsolutePath());&#13;&#10;                return ResponseEntity.notFound()&#13;&#10;                    .header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)&#13;&#10;                    .header(&quot;Access-Control-Allow-Methods&quot;, &quot;GET&quot;)&#13;&#10;                    .header(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;)&#13;&#10;                    .build();&#13;&#10;            }&#13;&#10;        } catch (IOException e) {&#13;&#10;            System.out.println(&quot;Error accediendo al archivo de cliente: &quot; + e.getMessage());&#13;&#10;            return ResponseEntity.internalServerError()&#13;&#10;                .header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)&#13;&#10;                .header(&quot;Access-Control-Allow-Methods&quot;, &quot;GET&quot;)&#13;&#10;                .header(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;)&#13;&#10;                .build();&#13;&#10;        }&#13;&#10;    }&#13;&#10;    &#13;&#10;    @GetMapping(&quot;/usuarios/{filename:.+}&quot;)&#13;&#10;    public ResponseEntity&lt;Resource&gt; getUsuarioImage(@PathVariable String filename) {&#13;&#10;        try {&#13;&#10;            // Decodificar el nombre del archivo si viene codificado&#13;&#10;            String decodedFilename = java.net.URLDecoder.decode(filename, &quot;UTF-8&quot;);&#13;&#10;            &#13;&#10;            Path filePath = usuariosPath.resolve(decodedFilename);&#13;&#10;            Resource resource = new UrlResource(filePath.toUri());&#13;&#10;            &#13;&#10;            if (resource.exists() &amp;&amp; resource.isReadable()) {&#13;&#10;                // Determinar el tipo MIME basado en la extensión del archivo&#13;&#10;                String contentType = determineContentType(decodedFilename);&#13;&#10;                &#13;&#10;                return ResponseEntity.ok()&#13;&#10;                    .header(HttpHeaders.CONTENT_DISPOSITION, &quot;inline; filename=\&quot;&quot; + decodedFilename + &quot;\&quot;&quot;)&#13;&#10;                    .header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)&#13;&#10;                    .header(&quot;Access-Control-Allow-Methods&quot;, &quot;GET&quot;)&#13;&#10;                    .header(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;)&#13;&#10;                    .contentType(MediaType.parseMediaType(contentType))&#13;&#10;                    .body(resource);&#13;&#10;            } else {&#13;&#10;                // Log para debugging&#13;&#10;                System.out.println(&quot;Archivo de usuario no encontrado: &quot; + decodedFilename);&#13;&#10;                System.out.println(&quot;Ruta completa: &quot; + filePath.toAbsolutePath());&#13;&#10;                return ResponseEntity.notFound()&#13;&#10;                    .header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)&#13;&#10;                    .header(&quot;Access-Control-Allow-Methods&quot;, &quot;GET&quot;)&#13;&#10;                    .header(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;)&#13;&#10;                    .build();&#13;&#10;            }&#13;&#10;        } catch (Exception e) {&#13;&#10;            System.err.println(&quot;Error sirviendo imagen de usuario: &quot; + e.getMessage());&#13;&#10;            return ResponseEntity.internalServerError()&#13;&#10;                .header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)&#13;&#10;                .header(&quot;Access-Control-Allow-Methods&quot;, &quot;GET&quot;)&#13;&#10;                .header(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;)&#13;&#10;                .build();&#13;&#10;        }&#13;&#10;    }&#13;&#10;    &#13;&#10;    @GetMapping(&quot;/productos/{filename:.+}&quot;)&#13;&#10;    public ResponseEntity&lt;Resource&gt; getProductImage(@PathVariable String filename) {&#13;&#10;        try {&#13;&#10;            // Decodificar el nombre del archivo si viene codificado&#13;&#10;            String decodedFilename = java.net.URLDecoder.decode(filename, &quot;UTF-8&quot;);&#13;&#10;            &#13;&#10;            Path filePath = productosPath.resolve(decodedFilename);&#13;&#10;            Resource resource = new UrlResource(filePath.toUri());&#13;&#10;            &#13;&#10;            if (resource.exists() &amp;&amp; resource.isReadable()) {&#13;&#10;                // Determinar el tipo MIME basado en la extensión del archivo&#13;&#10;                String contentType = determineContentType(decodedFilename);&#13;&#10;                &#13;&#10;                return ResponseEntity.ok()&#13;&#10;                    .header(HttpHeaders.CONTENT_DISPOSITION, &quot;inline; filename=\&quot;&quot; + decodedFilename + &quot;\&quot;&quot;)&#13;&#10;                    .header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)&#13;&#10;                    .header(&quot;Access-Control-Allow-Methods&quot;, &quot;GET&quot;)&#13;&#10;                    .header(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;)&#13;&#10;                    .contentType(MediaType.parseMediaType(contentType))&#13;&#10;                    .body(resource);&#13;&#10;            } else {&#13;&#10;                // Log para debugging&#13;&#10;                System.out.println(&quot;Archivo no encontrado: &quot; + decodedFilename);&#13;&#10;                System.out.println(&quot;Ruta completa: &quot; + filePath.toAbsolutePath());&#13;&#10;                return ResponseEntity.notFound()&#13;&#10;                    .header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)&#13;&#10;                    .header(&quot;Access-Control-Allow-Methods&quot;, &quot;GET&quot;)&#13;&#10;                    .header(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;)&#13;&#10;                    .build();&#13;&#10;            }&#13;&#10;        } catch (IOException e) {&#13;&#10;            System.out.println(&quot;Error accediendo al archivo: &quot; + e.getMessage());&#13;&#10;            return ResponseEntity.internalServerError()&#13;&#10;                .header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)&#13;&#10;                .header(&quot;Access-Control-Allow-Methods&quot;, &quot;GET&quot;)&#13;&#10;                .header(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;)&#13;&#10;                .build();&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @GetMapping(&quot;/{filename:.+}&quot;)&#13;&#10;    public ResponseEntity&lt;Resource&gt; getFile(@PathVariable String filename) {&#13;&#10;        try {&#13;&#10;            // Decodificar el nombre del archivo si viene codificado&#13;&#10;            String decodedFilename = java.net.URLDecoder.decode(filename, &quot;UTF-8&quot;);&#13;&#10;            &#13;&#10;            Path filePath = uploadPath.resolve(decodedFilename);&#13;&#10;            Resource resource = new UrlResource(filePath.toUri());&#13;&#10;            &#13;&#10;            if (resource.exists() &amp;&amp; resource.isReadable()) {&#13;&#10;                // Determinar el tipo MIME basado en la extensión del archivo&#13;&#10;                String contentType = determineContentType(decodedFilename);&#13;&#10;                &#13;&#10;                return ResponseEntity.ok()&#13;&#10;                    .header(HttpHeaders.CONTENT_DISPOSITION, &quot;inline; filename=\&quot;&quot; + decodedFilename + &quot;\&quot;&quot;)&#13;&#10;                    .header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)&#13;&#10;                    .header(&quot;Access-Control-Allow-Methods&quot;, &quot;GET&quot;)&#13;&#10;                    .header(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;)&#13;&#10;                    .contentType(MediaType.parseMediaType(contentType))&#13;&#10;                    .body(resource);&#13;&#10;            } else {&#13;&#10;                // Log para debugging&#13;&#10;                System.out.println(&quot;Archivo no encontrado: &quot; + decodedFilename);&#13;&#10;                System.out.println(&quot;Ruta completa: &quot; + filePath.toAbsolutePath());&#13;&#10;                System.out.println(&quot;Archivos en uploads:&quot;);&#13;&#10;                try {&#13;&#10;                    Files.list(uploadPath).forEach(System.out::println);&#13;&#10;                } catch (IOException e) {&#13;&#10;                    System.out.println(&quot;Error listando archivos: &quot; + e.getMessage());&#13;&#10;                }&#13;&#10;                return ResponseEntity.notFound()&#13;&#10;                    .header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)&#13;&#10;                    .header(&quot;Access-Control-Allow-Methods&quot;, &quot;GET&quot;)&#13;&#10;                    .header(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;)&#13;&#10;                    .build();&#13;&#10;            }&#13;&#10;        } catch (IOException e) {&#13;&#10;            System.out.println(&quot;Error accediendo al archivo: &quot; + e.getMessage());&#13;&#10;            return ResponseEntity.internalServerError()&#13;&#10;                .header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)&#13;&#10;                .header(&quot;Access-Control-Allow-Methods&quot;, &quot;GET&quot;)&#13;&#10;                .header(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;)&#13;&#10;                .build();&#13;&#10;        }&#13;&#10;    }&#13;&#10;    &#13;&#10;    private String determineContentType(String filename) {&#13;&#10;        String extension = &quot;&quot;;&#13;&#10;        if (filename.contains(&quot;.&quot;)) {&#13;&#10;            extension = filename.substring(filename.lastIndexOf(&quot;.&quot;)).toLowerCase();&#13;&#10;        }&#13;&#10;        &#13;&#10;        switch (extension) {&#13;&#10;            case &quot;.png&quot;:&#13;&#10;                return &quot;image/png&quot;;&#13;&#10;            case &quot;.jpg&quot;:&#13;&#10;            case &quot;.jpeg&quot;:&#13;&#10;                return &quot;image/jpeg&quot;;&#13;&#10;            case &quot;.gif&quot;:&#13;&#10;                return &quot;image/gif&quot;;&#13;&#10;            case &quot;.webp&quot;:&#13;&#10;                return &quot;image/webp&quot;;&#13;&#10;            case &quot;.bmp&quot;:&#13;&#10;                return &quot;image/bmp&quot;;&#13;&#10;            default:&#13;&#10;                return &quot;image/jpeg&quot;; // Por defecto JPEG&#13;&#10;        }&#13;&#10;    }&#13;&#10;    &#13;&#10;    @DeleteMapping(&quot;/{filename}&quot;)&#13;&#10;    public ResponseEntity&lt;?&gt; deleteFile(@PathVariable String filename) {&#13;&#10;        try {&#13;&#10;            Path filePath = uploadPath.resolve(filename);&#13;&#10;            if (Files.exists(filePath)) {&#13;&#10;                Files.delete(filePath);&#13;&#10;                return ResponseEntity.ok().body(&quot;Archivo eliminado correctamente&quot;);&#13;&#10;            } else {&#13;&#10;                return ResponseEntity.notFound().build();&#13;&#10;            }&#13;&#10;        } catch (IOException e) {&#13;&#10;            return ResponseEntity.internalServerError().body(&quot;Error al eliminar el archivo: &quot; + e.getMessage());&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/main/java/com/empresa/erp/controllers/OAuth2Controller.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/main/java/com/empresa/erp/controllers/OAuth2Controller.java" />
              <option name="originalContent" value="                .body(Map.of(&quot;error&quot;, &quot;Error generating Google login URL: &quot; + e.getMessage()));&#10;        }&#10;    }&#10;&#10;    @GetMapping(&quot;/status&quot;)&#10;    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; getOAuthStatus() {&#10;        Map&lt;String, Object&gt; status = new HashMap&lt;&gt;();&#10;&#10;        try {&#10;            ClientRegistration googleClient = clientRegistrationRepository.findByRegistrationId(&quot;google&quot;);&#10;&#10;            if (googleClient != null) {&#10;                status.put(&quot;googleConfigured&quot;, true);&#10;                status.put(&quot;clientId&quot;, googleClient.getClientId());&#10;                status.put(&quot;redirectUri&quot;, googleClient.getRedirectUri());&#10;                status.put(&quot;scopes&quot;, googleClient.getScopes());&#10;            } else {&#10;                status.put(&quot;googleConfigured&quot;, false);&#10;                status.put(&quot;error&quot;, &quot;Google OAuth client not found&quot;);&#10;            }&#10;        } catch (Exception e) {&#10;            status.put(&quot;googleConfigured&quot;, false);&#10;            status.put(&quot;error&quot;, e.getMessage());&#10;        }&#10;&#10;        return ResponseEntity.ok(status);&#10;    }&#10;&#10;    @PostMapping(&quot;/debug-error&quot;)&#10;    public ResponseEntity&lt;Map&lt;String, String&gt;&gt; debugOAuthError(&#10;            @RequestParam(required = false) String error,&#10;            @RequestParam(required = false) String error_description,&#10;            HttpServletRequest request) {&#10;&#10;        Map&lt;String, String&gt; debugInfo = new HashMap&lt;&gt;();&#10;        debugInfo.put(&quot;error&quot;, error != null ? error : &quot;no_error_param&quot;);&#10;        debugInfo.put(&quot;error_description&quot;, error_description != null ? error_description : &quot;no_description&quot;);&#10;        debugInfo.put(&quot;timestamp&quot;, String.valueOf(System.currentTimeMillis()));&#10;        debugInfo.put(&quot;requestUrl&quot;, request.getRequestURL().toString());&#10;        debugInfo.put(&quot;queryString&quot;, request.getQueryString() != null ? request.getQueryString() : &quot;none&quot;);&#10;&#10;        System.out.println(&quot;=== OAuth2 Debug Error ===&quot;);&#10;        debugInfo.forEach((key, value) -&gt; System.out.println(key + &quot;: &quot; + value));&#10;&#10;        return ResponseEntity.ok(debugInfo);&#10;    }&#10;}&#10;package com.empresa.erp.controllers;&#10;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.web.bind.annotation.*;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.security.oauth2.client.registration.ClientRegistrationRepository;&#10;import org.springframework.security.oauth2.client.registration.ClientRegistration;&#10;import jakarta.servlet.http.HttpServletRequest;&#10;import jakarta.servlet.http.HttpServletResponse;&#10;import java.util.Map;&#10;import java.util.HashMap;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/oauth&quot;)&#10;@CrossOrigin(origins = {&quot;http://localhost:3000&quot;, &quot;http://localhost:3001&quot;})&#10;public class OAuth2Controller {&#10;&#10;    @Autowired&#10;    private ClientRegistrationRepository clientRegistrationRepository;&#10;&#10;    @GetMapping(&quot;/google-login-url&quot;)&#10;    public ResponseEntity&lt;Map&lt;String, String&gt;&gt; getGoogleLoginUrl(HttpServletRequest request) {&#10;        try {&#10;            ClientRegistration googleClient = clientRegistrationRepository.findByRegistrationId(&quot;google&quot;);&#10;&#10;            if (googleClient == null) {&#10;                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Google OAuth client not configured&quot;));&#10;            }&#10;&#10;            String baseUrl = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort();&#10;            String authUrl = baseUrl + &quot;/oauth2/authorization/google&quot;;&#10;&#10;            Map&lt;String, String&gt; response = new HashMap&lt;&gt;();&#10;            response.put(&quot;authUrl&quot;, authUrl);&#10;            response.put(&quot;clientId&quot;, googleClient.getClientId());&#10;            response.put(&quot;redirectUri&quot;, googleClient.getRedirectUri());&#10;&#10;            return ResponseEntity.ok(response);&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;" />
              <option name="updatedContent" value="package com.empresa.erp.controllers;&#10;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.web.bind.annotation.*;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.security.oauth2.client.registration.ClientRegistrationRepository;&#10;import org.springframework.security.oauth2.client.registration.ClientRegistration;&#10;import jakarta.servlet.http.HttpServletRequest;&#10;import jakarta.servlet.http.HttpServletResponse;&#10;import java.util.Map;&#10;import java.util.HashMap;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/oauth&quot;)&#10;@CrossOrigin(origins = {&quot;http://localhost:3000&quot;, &quot;http://localhost:3001&quot;})&#10;public class OAuth2Controller {&#10;&#10;    @Autowired&#10;    private ClientRegistrationRepository clientRegistrationRepository;&#10;&#10;    @GetMapping(&quot;/google-login-url&quot;)&#10;    public ResponseEntity&lt;Map&lt;String, String&gt;&gt; getGoogleLoginUrl(HttpServletRequest request) {&#10;        try {&#10;            ClientRegistration googleClient = clientRegistrationRepository.findByRegistrationId(&quot;google&quot;);&#10;            &#10;            if (googleClient == null) {&#10;                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Map.of(&quot;error&quot;, &quot;Google OAuth client not configured&quot;));&#10;            }&#10;            &#10;            String baseUrl = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort();&#10;            String authUrl = baseUrl + &quot;/oauth2/authorization/google&quot;;&#10;            &#10;            Map&lt;String, String&gt; response = new HashMap&lt;&gt;();&#10;            response.put(&quot;authUrl&quot;, authUrl);&#10;            response.put(&quot;clientId&quot;, googleClient.getClientId());&#10;            response.put(&quot;redirectUri&quot;, googleClient.getRedirectUri());&#10;            &#10;            return ResponseEntity.ok(response);&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                .body(Map.of(&quot;error&quot;, &quot;Error generating Google login URL: &quot; + e.getMessage()));&#10;        }&#10;    }&#10;&#10;    @GetMapping(&quot;/status&quot;)&#10;    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; getOAuthStatus() {&#10;        Map&lt;String, Object&gt; status = new HashMap&lt;&gt;();&#10;        &#10;        try {&#10;            ClientRegistration googleClient = clientRegistrationRepository.findByRegistrationId(&quot;google&quot;);&#10;            &#10;            if (googleClient != null) {&#10;                status.put(&quot;googleConfigured&quot;, true);&#10;                status.put(&quot;clientId&quot;, googleClient.getClientId());&#10;                status.put(&quot;redirectUri&quot;, googleClient.getRedirectUri());&#10;                status.put(&quot;scopes&quot;, googleClient.getScopes());&#10;            } else {&#10;                status.put(&quot;googleConfigured&quot;, false);&#10;                status.put(&quot;error&quot;, &quot;Google OAuth client not found&quot;);&#10;            }&#10;        } catch (Exception e) {&#10;            status.put(&quot;googleConfigured&quot;, false);&#10;            status.put(&quot;error&quot;, e.getMessage());&#10;        }&#10;        &#10;        return ResponseEntity.ok(status);&#10;    }&#10;&#10;    @PostMapping(&quot;/debug-error&quot;)&#10;    public ResponseEntity&lt;Map&lt;String, String&gt;&gt; debugOAuthError(&#10;            @RequestParam(required = false) String error,&#10;            @RequestParam(required = false) String error_description,&#10;            HttpServletRequest request) {&#10;        &#10;        Map&lt;String, String&gt; debugInfo = new HashMap&lt;&gt;();&#10;        debugInfo.put(&quot;error&quot;, error != null ? error : &quot;no_error_param&quot;);&#10;        debugInfo.put(&quot;error_description&quot;, error_description != null ? error_description : &quot;no_description&quot;);&#10;        debugInfo.put(&quot;timestamp&quot;, String.valueOf(System.currentTimeMillis()));&#10;        debugInfo.put(&quot;requestUrl&quot;, request.getRequestURL().toString());&#10;        debugInfo.put(&quot;queryString&quot;, request.getQueryString() != null ? request.getQueryString() : &quot;none&quot;);&#10;        &#10;        System.out.println(&quot;=== OAuth2 Debug Error ===&quot;);&#10;        debugInfo.forEach((key, value) -&gt; System.out.println(key + &quot;: &quot; + value));&#10;        &#10;        return ResponseEntity.ok(debugInfo);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/src/main/resources/application.properties">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/main/resources/application.properties" />
              <option name="originalContent" value="spring.datasource.url=jdbc:mysql://localhost:3306/erp_sena&#10;spring.datasource.username=root&#10;spring.datasource.password=&#10;spring.jpa.hibernate.ddl-auto=update&#10;spring.jpa.show-sql=true&#10;spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect&#10;server.port=8081&#10;jwt.secret=QwErTyUiOpAsDfGhJkLzXcVbNm1234567890!@#&#10;&#10;# OAuth2 Configuration for Google&#10;spring.security.oauth2.client.registration.google.client-id=1020550477577-p2agvl0se7daqnfv9k0vijg05fs1ol0d.apps.googleusercontent.com&#10;spring.security.oauth2.client.registration.google.client-secret=GOCSPX-your-actual-client-secret-here&#10;spring.security.oauth2.client.registration.google.scope=openid,email,profile&#10;spring.security.oauth2.client.registration.google.redirect-uri=http://localhost:8081/login/oauth2/code/google&#10;spring.security.oauth2.client.registration.google.authorization-grant-type=authorization_code&#10;&#10;# Provider configuration&#10;spring.security.oauth2.client.provider.google.authorization-uri=https://accounts.google.com/o/oauth2/auth&#10;spring.security.oauth2.client.provider.google.token-uri=https://oauth2.googleapis.com/token&#10;spring.security.oauth2.client.provider.google.user-info-uri=https://www.googleapis.com/oauth2/v2/userinfo&#10;spring.security.oauth2.client.provider.google.user-name-attribute=email&#10;&#10;# Logging for debugging OAuth2&#10;logging.level.org.springframework.security=DEBUG&#10;logging.level.org.springframework.security.oauth2=DEBUG&#10;logging.level.org.springframework.web=DEBUG&#10;" />
              <option name="updatedContent" value="spring.datasource.url=jdbc:mysql://localhost:3306/erp_sena&#10;spring.datasource.username=root&#10;spring.datasource.password=&#10;spring.jpa.hibernate.ddl-auto=update&#10;spring.jpa.show-sql=true&#10;spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect&#10;server.port=8081&#10;jwt.secret=QwErTyUiOpAsDfGhJkLzXcVbNm1234567890!@#&#10;&#10;# OAuth2 Configuration for Google&#10;spring.security.oauth2.client.registration.google.client-id=1020550477577-p2agvl0se7daqnfv9k0vijg05fs1ol0d.apps.googleusercontent.com&#10;spring.security.oauth2.client.registration.google.client-secret=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&#10;spring.security.oauth2.client.registration.google.scope=openid,email,profile&#10;spring.security.oauth2.client.registration.google.redirect-uri=http://localhost:8081/login/oauth2/code/google&#10;spring.security.oauth2.client.registration.google.authorization-grant-type=authorization_code&#10;&#10;# Provider configuration&#10;spring.security.oauth2.client.provider.google.authorization-uri=https://accounts.google.com/o/oauth2/auth&#10;spring.security.oauth2.client.provider.google.token-uri=https://oauth2.googleapis.com/token&#10;spring.security.oauth2.client.provider.google.user-info-uri=https://www.googleapis.com/oauth2/v2/userinfo&#10;spring.security.oauth2.client.provider.google.user-name-attribute=email&#10;&#10;# Logging for debugging OAuth2&#10;logging.level.org.springframework.security=DEBUG&#10;logging.level.org.springframework.security.oauth2=DEBUG&#10;logging.level.org.springframework.web=DEBUG" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>